

  星期一, 2017年04月24日
  ================

============================================

js_note

===========================================

#继承 js的继承使用prototype来继承所有的对象的属.

=========================================

msd js (https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters)

=============================================================================================

#带做的事

- 第一项
  做node的开发，开发一个晓得聊天站；
- 第二项 
学习js的完整知识

======================================

星期一, 2017年04月24日 15时37分16秒

======================================

#delete object.name
这样能删除这个属性。
而delete 全局变量也是可以的
delete i

===============================

#相等 new  object的创建的对象是不能相等的（==）（===）

==============================

#setter、#getter
{get :function(){return this.name),
set :function(y){this.name=y;
}
}

==========================================

#垃圾回收：


a计数法，没有对象引用的变量就销毁，但是容易引内存泄漏;


b基本浏览器的采用，标记清楚法，定期的从一个root根出发，寻找有没有引用的对象，如果没有人引用就释放他的内存。

====================

#单线程
js因为有回调异步的存在，所以不阻塞;

=================================

#关系数据库的表结构映射

==============================


	标签
	==

- setter
- 相等
- 继承
- 关系数据库的表结构映射
- 单线程
- getter
- 垃圾回收
- 带做的事
- delete


  星期二, 2017年04月25日
  ================

#promise
利用then和catch

====================================

新建一个promise的对象
var p1=new Promise(test);


function test(){}


输出一个对象这个Promise 对象就是有then和catch 的区分;

============================

on()
live()
delegate()
 最好选择on（）

=============================

跨域的方法


XMLHttpRequest


$.get(url,callback())


$.post(url,callback())


$.getJSON(url,callback())


JSONP


	标签
	==

- promise


  星期三, 2017年04月26日
  ================

#nodeJs




	node.js跨域需要添加头{"Aceess-Contorl-Allow-Origin":"*"}
	=================================================





	koa还有就是response的数据不是在body里
	==========================





	koa而是在response的data里面;
	======================

=============================

 #angular.js


+++++++++++++++++++++++


使用$compile进行编译


具体做法如下


例如




	var compile=$compile("HTMLstring")($scope);
	===========================================



将它注册到html的文件中。使用jquery就可以实现，这种方法很正常，还有效。

==========================

ng-option遍历的是{}和数组[]

ng-repeat便利的是[]

ng-option实现方法

<select ng-option="x for (x,y) in object " ng-model="selection">
</select>



		对于select的值来说，select是指代value的，不是key
		==================================

===========================================


		angular.copy()\\
		================


		angular.isNumber()\\
		====================


		angular.isString()\\
		====================


		angular.lowercase()\\
		=====================


		angular.uppercase()
		===================

========================================


		对于angular-include=“html”来说实现的方法就是采用跨域的方法。\\要在本地设置白名单，还要在客户端使用“access-contorl-allow-origin”;\\所以很麻烦。
		===================================================================================================

================================


	angular的注入 模块化，降低耦合，实现代码的可重用和可修改
	================================


		app.factory('name',function(){})
		================================


		遗憾的是factory本身没有办法输入参数，它只能在内部生成一个对象，对象内部包含函数，return生成的函数
		=======================================================

实现他的函数生成

=============================


	路由
	==


	angular的路由就是针对url生成的
	====================


		config阶段是给了ng上下文一个针对constant与provider修改其内部属性的一个阶段而run阶段是在config之后的在运行独立的代码块，通常写法runBlock简单的说一下就是ng启动阶段是 config-->run-->compile/link
		===================================================================================================================================

[file:///home/swnb/Downloads/bVvz25.png]


	config里面主要是路由
	=============

====================================

2017年04月26日  星期三  14时51分40秒


	标签
	==

- angular
- nodejs


  星期四, 2017年04月27日
  ================


	Content-Encoding: gzip
	======================


	Content-Language: en,zh
	=======================


	Content-Typ
	===========

#特殊


  编码规则，一开始没有charset后面加的
  =====================


  “Content-Type“：”text/html;charset=utf-8“
  ========================================


	这是非常特殊的
	=======

=======================


	对于http模块的response，response的end和write，end必须要写上，如果没有end，则服务端不会终止这个连接，客户端解析不正常
	===========================================================================

===========================


	vue的思路
	======


		取id，然后在id内部就可以穿插{{}}变量，这样的变量就可以实现绑定，实现方法十分方便，例如：在内部实现他的一个新的对象，例子如下
		==================================================================


	new Vue(
	========


	{
	=


	el:"id",
	========


	data:{
	======


	variable:value
	==============


	}
	=


	}
	=


	)
	=

=========================================


	与angular一起来看cue.js
	==================


	ng-include 和v-thml
	==================


	一起设置html页面
	==========

===============================


	新技能get
	======


	字体变平滑
	=====


	--webkit-font-smoothing
	=======================


	css3新属性
	=======

==============================

===========================

电源管理服务


  tlp
  ===

====================


  关于node的总结
  =========


  对于node来说，原生的node对于get方法很简单，因为没有body部分，而对于post来说，就是在createServer后的的request部分进行监听，例  如request.on('data',function(data){console.log(data)}),而koa对于get有request.method,request.url。post有request.body,request.type两种。在客户端使用xhr的话，get不要求什么，不用设置头，直接发送url，而post的话是要求设置头部的信息的。
  =====================================================================================================================================================================================================================================================================

===========================================================


  星期四, 2017年04月27日 20时48分11秒
  ==========================


  明天开始学习vue，一星期内学会，今天开始学习
  =======================


	标签
	==

- 特殊


  星期五, 2017年04月28日
  ================


  vue的思想MVVM
  ==========


	即model——view——viewModel
	=======================


	viewmodel控制监听和反馈，它就是vue
	=======================


	view就是页面层，用来和人交互
	================


	model就是javascipt层，给开发者实现他的想法
	============================


  即~view-->>vue (viewModel)-->>model (js)-->> vue--> view
  =======================================================


	典型angular和vue都是这种模型，本身，在model和view并无关系，使用一个中介，来解决逻辑和页面的关系，避免了代码的耦合性，提高了可维护性
	===========================================================================

[file:///home/swnb/Pictures/bg2015020110.png]

=================================


  mvc
  ===


	mvc即model -->> view --> controller <<-->> model
	===============================================

[file:///home/swnb/Pictures/bg2015020105.png]

==============================


  mvp
  ===

[file:///home/swnb/Pictures/bg2015020109.png]

====================




